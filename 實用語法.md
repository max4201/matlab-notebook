# MATLAB實用語法
## MATLAB三維強度圖
```matlab
clear;clc;close all
%--------------------------------------------------------------------------
% 相關繪圖指令提示:
% image系列:
% 只能在Z=0平面上畫的2D圖片，要處理3D不建議使用。
% surface系列:
% surface 主要的輸入方法是 surface(XI,YI,ZI,C)，是低階原生方法。不建議使用。
% surf 輸入方式幾乎與surface相同，但包裝了一些顏色控制、父層指定等。建議用這個。
% pcolor 主要輸入方法是 pcolor(XI,YI,C) 基本上就是強制ZI在0的surf，也有包裝顏色控制、父層指定。也不建議使用。
%--------------------------------------------------------------------------
% 4D強度圖展示介紹
%--
% 準備4D強度資料(Scalar Volume Data，我稱之為「4D Scalar Volume Data」)。
% MATLAB建議可用slice、isosurface方法來展示。
% REF:https://www.mathworks.com/help/matlab/visualize/overview-of-volume-visualization.html
%--
% 其中，4D Scalar Volume Data由大寫的XI,YI,ZI,CI所組成，皆為3維陣列。
% 大寫XI、YI、ZI、CI依照本人寫作習慣留給4D使用。
% --
% 依照本人定義，此資料的描述方式是以網格節點為主，因此改為:
% 網格資料為:XI_Node_4D、YI_Node_4D、ZI_Node_4D。為3維陣列。
% 對應的強度值在網格節點上的值就必須為CI_Node_4D_interp。為3維陣列。
% 對應的強度值在塊體中心的值就必須為CI_Node_4D_flat_nan(把用不到的部分填nan)或
% CI_Node_4D_flat_inf(把用不到的部分填nan)。為3維陣列。
% 範例:
[XI_Node_4D,YI_Node_4D,ZI_Node_4D] = meshgrid(1:5,1:4,1:3);
CI_Node_4D_interp=zeros(size(XI_Node_4D));
for i=1:numel(CI_Node_4D_interp)
    CI_Node_4D_interp(i)=i;
end
%--
% X方向有5個節點，Y方向上有4個節點，Z方向上有3個節點，則大小為<4x5x3>。
% 注意，很麻煩的是XY是寫成矩陣，Y大小在前，X大小在後，第三個是Z大小。
% XI_Node_4D可展示為
% XI_Node_4D(:,:,1) =
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
% XI_Node_4D(:,:,2) =
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
% XI_Node_4D(:,:,3) =
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
% YI_Node_4D可展示為
% YI_Node_4D(:,:,1) =
%      1     1     1     1     1
%      2     2     2     2     2
%      3     3     3     3     3
%      4     4     4     4     4
% YI_Node_4D(:,:,2) =
%      1     1     1     1     1
%      2     2     2     2     2
%      3     3     3     3     3
%      4     4     4     4     4
% YI_Node_4D(:,:,3) =
%      1     1     1     1     1
%      2     2     2     2     2
%      3     3     3     3     3
%      4     4     4     4     4
% ZI_Node_4D可展示為
% ZI_Node_4D(:,:,1) =
%      1     1     1     1     1
%      1     1     1     1     1
%      1     1     1     1     1
%      1     1     1     1     1
% ZI_Node_4D(:,:,2) =
%      2     2     2     2     2
%      2     2     2     2     2
%      2     2     2     2     2
%      2     2     2     2     2
% ZI_Node_4D(:,:,3) =
%      3     3     3     3     3
%      3     3     3     3     3
%      3     3     3     3     3
%      3     3     3     3     3
% 強度值(顏色)CI_Node_4D_interp陣列可以展示為:
% CI_Node_4D_interp(:,:,1) =
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
% CI_Node_4D_interp(:,:,2) =
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
% CI_Node_4D_interp(:,:,3) =
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
% --
% 注意!CI_Node_4D_interp的部分有Bug，全部數值都一樣的時候會Slice方法會錯誤，除了0沒問題之外。
%--------------------------------------------------------------------------
% 接著可使用slice去切出要看的網格
%--
% 指定X切面，可複選(寫成陣列)
xslice = [4,3]; 
% 指定Y切面，可複選(寫成陣列)
yslice = [3];
% 指定Z切面，可複選(寫成陣列)
zslice = [1 2];
% 繪圖，注意! V的部分有Bug，全部數值都一樣的時候會錯誤，除了0沒問題之外。
try
    figure
    slice(XI_Node_4D,YI_Node_4D,ZI_Node_4D,CI_Node_4D_interp,xslice,yslice,zslice)
    set(gca,'CLim',[0,50])
    shading interp
    title('shading interp: CI Node 4D interp')
catch ME2
	 disp(ME2.message)
end
try
    figure
    slice(XI_Node_4D,YI_Node_4D,ZI_Node_4D,CI_Node_4D_interp,xslice,yslice,zslice)
    set(gca,'CLim',[0,50])
    title('shading faceted: CI Node 4D interp')
catch ME2
	 disp(ME2.message)
end
%--------------------------------------------------------------------------
% 展示各節點的數值
disp('--')
disp('展示各節點的數值:')
for i=1:numel(CI_Node_4D_interp)
    disp([...
        num2str(XI_Node_4D(i)),',',...
        num2str(YI_Node_4D(i)),',',...
        num2str(ZI_Node_4D(i)),',',...
        num2str(CI_Node_4D_interp(i))...
        ])
end
disp('--')
%
% 更有效率的整理方法:
all_node_list=[XI_Node_4D(:),YI_Node_4D(:),ZI_Node_4D(:),CI_Node_4D_interp(:)];
disp('展示各節點的數值2:')
disp(all_node_list)
%--------------------------------------------------------------------------
% CI_Node_4D_flat_nan:
%--
CI_Node_4D_flat_nan=CI_Node_4D_interp;CI_Node_4D_flat_nan(:,:,end)=NaN;CI_Node_4D_flat_nan(:,end,:)=NaN;CI_Node_4D_flat_nan(end,:,:)=NaN;
% 強度值(顏色)CI_Node_4D_flat_nan陣列可以展示為:
% CI_Node_4D_flat_nan(:,:,1) =
%      1     5     9    13   NaN
%      2     6    10    14   NaN
%      3     7    11    15   NaN
%    NaN   NaN   NaN   NaN   NaN
% CI_Node_4D_flat_nan(:,:,2) =
%     21    25    29    33   NaN
%     22    26    30    34   NaN
%     23    27    31    35   NaN
%    NaN   NaN   NaN   NaN   NaN
% CI_Node_4D_flat_nan(:,:,3) =
%    NaN   NaN   NaN   NaN   NaN
%    NaN   NaN   NaN   NaN   NaN
%    NaN   NaN   NaN   NaN   NaN
%    NaN   NaN   NaN   NaN   NaN
% --
% 注意!CI_Node_4D_flat_nan用在slice方法的時候，邊界會切不出來。
% 注意!CI_Node_4D_flat_inf用在slice方法的時候，邊界會切出異常值。
%--------------------------------------------------------------------------
try
    figure
    slice(XI_Node_4D,YI_Node_4D,ZI_Node_4D,CI_Node_4D_flat_nan,xslice,yslice,zslice)
    set(gca,'CLim',[0,50])
    title('shading faceted: CI Node 4D flat nan')
catch ME2
	 disp(ME2.message)
end
%--------------------------------------------------------------------------
% CI_Node_4D_flat_inf:
%--
CI_Node_4D_flat_inf=CI_Node_4D_interp;CI_Node_4D_flat_inf(:,:,end)=Inf;CI_Node_4D_flat_inf(:,end,:)=Inf;CI_Node_4D_flat_inf(end,:,:)=Inf;
% 強度值(顏色)CI_Node_4D_flat_nan陣列可以展示為:
% CI_Node_4D_flat_inf(:,:,1) =
%      1     5     9    13   Inf
%      2     6    10    14   Inf
%      3     7    11    15   Inf
%    Inf   Inf   Inf   Inf   Inf
% CI_Node_4D_flat_inf(:,:,2) =
%     21    25    29    33   Inf
%     22    26    30    34   Inf
%     23    27    31    35   Inf
%    Inf   Inf   Inf   Inf   Inf
% CI_Node_4D_flat_inf(:,:,3) =
%    Inf   Inf   Inf   Inf   Inf
%    Inf   Inf   Inf   Inf   Inf
%    Inf   Inf   Inf   Inf   Inf
%    Inf   Inf   Inf   Inf   Inf
% --
% 注意!CI_Node_4D_flat_nan用在slice方法的時候，邊界會切不出來。
% 注意!CI_Node_4D_flat_inf用在slice方法的時候，邊界會切出異常值。
%--------------------------------------------------------------------------
try
    figure
    slice(XI_Node_4D,YI_Node_4D,ZI_Node_4D,CI_Node_4D_flat_inf,xslice,yslice,zslice)
    set(gca,'CLim',[0,50])
    title('shading faceted: 用CI Node 4D flat inf')
catch ME2
	 disp(ME2.message)
end
%--------------------------------------------------------------------------
% 結論: 
% 1.基本上slice只適合用CI_Node_4D_interp，而且最好要用shading interp才不會
% 有錯誤偏移。
% 2.內插方法有些時候有問題，要注意。
% 3.沒有CI_Node_4D_interp的情境不建議使用slice。
%--------------------------------------------------------------------------
```
```matlab
clear;clc;close all
%--------------------------------------------------------------------------
% 4D強度圖展示介紹 自己填值方法介紹
%--
% 準備4D強度資料(Scalar Volume Data，我稱之為「4D Scalar Volume Data」)。
% MATLAB建議可用slice、isosurface方法來展示。
% REF:https://www.mathworks.com/help/matlab/visualize/overview-of-volume-visualization.html
%--
% 其中，4D Scalar Volume Data由大寫的XI,YI,ZI,CI所組成，皆為3維陣列。
% 大寫XI、YI、ZI、CI依照本人寫作習慣留給4D使用。
% --
% 依照本人定義，此資料的描述方式是以網格節點為主，因此改為:
% 網格資料為:XI_Node_4D、YI_Node_4D、ZI_Node_4D。為3維陣列。
% 對應的強度值在網格節點上的值就必須為CI_Node_4D_interp。為3維陣列。
% 對應的強度值在塊體中心的值就必須為CI_Node_4D_flat_nan(把用不到的部分填nan)或
% CI_Node_4D_flat_inf(把用不到的部分填nan)。為3維陣列。
% 範例:
[XI_Node_4D,YI_Node_4D,ZI_Node_4D] = meshgrid(1:5,1:4,1:3);
CI_Node_4D_interp=zeros(size(XI_Node_4D));
for i=1:numel(CI_Node_4D_interp)
    CI_Node_4D_interp(i)=i;
end
%--
% X方向有5個節點，Y方向上有4個節點，Z方向上有3個節點，則大小為<4x5x3>。
% 注意，很麻煩的是XY是寫成矩陣，Y大小在前，X大小在後，第三個是Z大小。
% XI_Node_4D可展示為
% XI_Node_4D(:,:,1) =
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
% XI_Node_4D(:,:,2) =
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
% XI_Node_4D(:,:,3) =
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
% YI_Node_4D可展示為
% YI_Node_4D(:,:,1) =
%      1     1     1     1     1
%      2     2     2     2     2
%      3     3     3     3     3
%      4     4     4     4     4
% YI_Node_4D(:,:,2) =
%      1     1     1     1     1
%      2     2     2     2     2
%      3     3     3     3     3
%      4     4     4     4     4
% YI_Node_4D(:,:,3) =
%      1     1     1     1     1
%      2     2     2     2     2
%      3     3     3     3     3
%      4     4     4     4     4
% ZI_Node_4D可展示為
% ZI_Node_4D(:,:,1) =
%      1     1     1     1     1
%      1     1     1     1     1
%      1     1     1     1     1
%      1     1     1     1     1
% ZI_Node_4D(:,:,2) =
%      2     2     2     2     2
%      2     2     2     2     2
%      2     2     2     2     2
%      2     2     2     2     2
% ZI_Node_4D(:,:,3) =
%      3     3     3     3     3
%      3     3     3     3     3
%      3     3     3     3     3
%      3     3     3     3     3
% 強度值(顏色)CI_Node_4D_interp陣列可以展示為:
% CI_Node_4D_interp(:,:,1) =
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
% CI_Node_4D_interp(:,:,2) =
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
% CI_Node_4D_interp(:,:,3) =
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%--------------------------------------------------------------------------

%--------------------------------------------------------------------------
% CI_Node_4D_interp填入的方法1: 每個Z分開填入
% Z=1時填入CI_Node_4D_interp(:,:,1)，
% Z=2時填入CI_Node_4D_interp(:,:,2)，
% Z=3時填入CI_Node_4D_interp(:,:,3)，
% ....
%--------------------------------------------------------------------------
```
```matlab
%--------------------------------------------------------------------------
% 製作一個平面
% 用小寫的xi,yi,zi,ci就是用來描述一個平面的二維強度資料(2D+1D)
%--
% 從Node的想法開始製作平面
[xi,yi] = meshgrid(1:5,1:4);
zi=zeros(size(xi));
ci_interp=zi;
% 填入指定顏色
for i=1:numel(ci_interp)
    ci_interp(i)=i;
end
ci_flat_inf=ci_interp;ci_flat_inf(:,end)=Inf;ci_flat_inf(end,:)=Inf;
ci_flat_nan=ci_interp;ci_flat_nan(:,end)=NaN;ci_flat_nan(end,:)=NaN;
%--
% 繪圖展示差異
figure
surf(xi,yi,zi,ci_interp)
shading faceted
hold on
surf(xi,yi,zi+1,ci_flat_inf)
shading faceted
title('shading faceted: Z=0是ci interp陣列，Z=1是ci flat陣列')
figure
surf(xi,yi,zi,ci_interp)
shading flat
hold on
surf(xi,yi,zi+1,ci_flat_inf)
shading flat
title('shading flat: Z=0是ci interp陣列，Z=1是ci flat陣列')
figure
surf(xi,yi,zi,ci_interp)
shading interp
hold on
surf(xi,yi,zi+1,ci_flat_inf)
shading interp
title('shading interp: Z=0是ci interp陣列，Z=1是ci flat陣列(會變形不可用)')
%--------------------------------------------------------------------------
% 解析:
% xi,yi,zi,c尺寸都是mxn。本範例中:
% xi =
% 
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
% 
% yi =
% 
%      1     1     1     1     1
%      2     2     2     2     2
%      3     3     3     3     3
%      4     4     4     4     4
% 
% zi =
% 
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%
% ci_interp =
% 
%      1     5     9    13    17
%      2     6    10    14    18
%      3     7    11    15    19
%      4     8    12    16    20
%
% ci_flat_inf =
%
%      1     5     9    13   Inf
%      2     6    10    14   Inf
%      3     7    11    15   Inf
%    Inf   Inf   Inf   Inf   Inf
%
% ci_flat_nan =
%
%      1     5     9    13   NaN
%      2     6    10    14   NaN
%      3     7    11    15   NaN
%    NaN   NaN   NaN   NaN   NaN
%--
% 在surface系列繪圖時，shading方法設定為flat或faceted時，基本上只有ci_flat裡
% 非Inf位置的顏色值會被畫出。所以用ci_interp或用ci_flat畫出來的結果在flat或faceted時
% 相同，但要注意的是，自動的取得顏色範圍時，是將ci的所有數值拿去找出最大最小值，
% ci_interp 與 ci_flat元素內容不同，自然取得範圍會不同，可手動強制設定顏色範圍避免此問題。
% 選擇故意用Inf填充到ci_flat_inf沒用的位置是因為正常繪圖不會用到這種數字，NaN保留給透明。
% 這在檢查矩陣時很有用，看到有Inf的就是flat或faceted法專用的資料。
% 但如果沒有這個需求，設計使用NaN填充到沒用的位置而產生ci_flat_nan也是可行的。
%--
% 通常在數值模擬中，我們會設計網格，並把我們的計算點放在網格節點上，此時要選擇
% shading interp方法，而且手上自行準備充足的所有資料填入ci_interp中。此時節點
% 位置上的數值完全與設定值一致，中間會被漸進內差而平滑展示。
%--
% 在數值模擬中另外可以設計不同的網格，但計算點放在網格中心，此時要選擇 shading flat
% 或 shading faceted方法。此時要準備網格節點與網格中心顏色值，而網格中心顏色值數量
% 必定比節點資料少，因此可自行添加Inf整理成類似ci_flat_inf的形式。
%--------------------------------------------------------------------------
% 在網格節點上(ci_interp資料)，整理各節點位置與值
all_node_list_1=[xi(:) yi(:) zi(:) ci_interp(:)];
disp('在網格節點上(ci_interp資料) 依序資料:')
disp(all_node_list_1)
% 打亂資料
all_node_list_random_1=all_node_list_1(randperm(length(all_node_list_1(:,1))),:);
disp('在網格節點上(ci_interp資料) 打亂後資料:')
disp(all_node_list_random_1)
% 重新排序
all_node_list_sorted_1=sortrows(all_node_list_random_1,[1,2,3]);
disp('在網格節點上(ci_interp資料) 重新排序後資料:')
disp(all_node_list_sorted_1)
%--
% 在網格中心(ci_flat_inf資料)，整理各節點位置與值
all_node_list_2=[xi(:) yi(:) zi(:) ci_flat_inf(:)];
disp('在網格中心(ci_flat_inf資料) 依序資料:')
disp(all_node_list_2)
%--
% 打亂資料
all_node_list_random_2=all_node_list_2(randperm(length(all_node_list_2(:,1))),:);
disp('在網格中心(ci_flat_inf資料) 打亂後資料:')
disp(all_node_list_random_2)
% 重新排序
all_node_list_sorted_2=sortrows(all_node_list_random_2,[1,2,3]);
disp('在網格中心(ci_flat_inf資料) 重新排序後資料:')
disp(all_node_list_sorted_2)
% 找出元素資料
all_element_list=all_node_list_sorted_2(~isinf(all_node_list_sorted_2(:,4)),4);
disp('在網格中心(ci_flat_inf資料) 元素資料清單:')
disp(all_element_list)
% 找出元素陣列
X_element_count=length(xi(1,:))-1;
Y_element_count=length(xi(:,1))-1;
all_element_array=reshape(all_node_list_sorted_2(~isinf(all_node_list_sorted_2(:,4)),4),Y_element_count,[]);
disp('在網格中心(ci_flat_inf資料) 元素陣列資料清單:')
disp(all_element_array)
%--------------------------------------------------------------------------
```
```matlab
%**************************************************************************
%   Name: make_custom_mesh_data.m
%   Copyright:  
%   Author: HsiupoYeh
%   Version: v20210222a
%   Description:
%   將surf對應使用的surf(xi_Node_3D,yi_Node_3D,zi_Node_3D,ci_Node_3D_flat_nan)同樣參
%   數輸入到本函數中，將返回網格所需的資料點，後續可用plot3方法繪製出網格。
%   呼叫方式:
%   custom_mesh_data_array=make_custom_mesh_data(xi_Node_3D,yi_Node_3D,zi_Node_3D,ci_Node_3D_flat_nan)
%   plot3(custom_mesh_data_array(:,1),custom_mesh_data_array(:,2),custom_mesh_data_array(:,3),'r')
%**************************************************************************
function custom_mesh_data_array=make_custom_mesh_data(xi_Node_3D,yi_Node_3D,zi_Node_3D,ci_Node_3D_flat_nan)
    %----------------------------------------------------------------------
    %確認網格尺寸
    [temp_m,temp_n]=size(ci_Node_3D_flat_nan);
    %--------------------------------------------------------------------------
    % 整理自訂網格: 用不連續的網格節點向量來繪製網格
    %--
    % 準備空向量
    temp_mesh_x_vector=[];
    temp_mesh_y_vector=[];
    temp_mesh_z_vector=[];
    %--------------------------------------------------------------------------
    % 整理X方向的線(第一條)
    for i_x=1:1
        % 取出第某個X值的網格節點資訊
        temp_x_node_vector=xi_Node_3D(:,i_x);
        temp_y_node_vector=yi_Node_3D(:,i_x);
        temp_z_node_vector=zi_Node_3D(:,i_x);
        temp_ci_node_vector=ci_Node_3D_flat_nan(:,i_x);
        %--
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;
        %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
        %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
        for i_ci_node_index=1:length(temp_ci_node_vector)-1
            %disp(['#',num2str(i_ci_node_index),'=',num2str(temp_ci_node_vector(i_ci_node_index))])
            if isnan(temp_ci_node_vector(i_ci_node_index))==1
                if temp_start_x==0 && temp_end_x==0
                    %disp('略過')
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index);
                    temp_end_y=temp_y_node_vector(i_ci_node_index);
                    temp_end_z=temp_z_node_vector(i_ci_node_index);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                    %--
                    %disp('決定此片段...')
                    temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
                    temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
                    temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
                    temp_start_x=0;
                    temp_start_y=0;
                    temp_start_z=0;
                    temp_end_x=0;
                    temp_end_y=0;
                    temp_end_z=0;
                end
            else
                if temp_start_x==0 && temp_end_x==0
                    temp_start_x=temp_x_node_vector(i_ci_node_index);
                    temp_start_y=temp_y_node_vector(i_ci_node_index);
                    temp_start_z=temp_z_node_vector(i_ci_node_index);
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                end            
            end      
        end
        %disp('決定此片段...')
        temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
        temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
        temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;    
    end
    %--
    % 整理X方向的線(中間)
    for i_x=2:temp_n-1
        % 取出第某個X值的網格節點資訊
        temp_x_node_vector=xi_Node_3D(:,i_x);
        temp_y_node_vector=yi_Node_3D(:,i_x);
        temp_z_node_vector=zi_Node_3D(:,i_x);
        temp_ci_node_vector=ci_Node_3D_flat_nan(:,i_x);
        temp_x_node_vector2=xi_Node_3D(:,i_x-1);
        temp_y_node_vector2=yi_Node_3D(:,i_x-1);
        temp_z_node_vector2=zi_Node_3D(:,i_x-1);
        temp_ci_node_vector2=ci_Node_3D_flat_nan(:,i_x-1);
        %--
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;
        %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
        %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
        for i_ci_node_index=1:length(temp_ci_node_vector)-1
            %disp(['#',num2str(i_ci_node_index),'=',num2str(temp_ci_node_vector(i_ci_node_index))])
            if isnan(temp_ci_node_vector(i_ci_node_index))==1 && isnan(temp_ci_node_vector2(i_ci_node_index))==1
                if temp_start_x==0 && temp_end_x==0
                    %disp('略過')
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index);
                    temp_end_y=temp_y_node_vector(i_ci_node_index);
                    temp_end_z=temp_z_node_vector(i_ci_node_index);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                    %--
                    %disp('決定此片段...')
                    temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
                    temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
                    temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
                    temp_start_x=0;
                    temp_start_y=0;
                    temp_start_z=0;
                    temp_end_x=0;
                    temp_end_y=0;
                    temp_end_z=0;
                end
            else
                if temp_start_x==0 && temp_end_x==0
                    temp_start_x=temp_x_node_vector(i_ci_node_index);
                    temp_start_y=temp_y_node_vector(i_ci_node_index);
                    temp_start_z=temp_z_node_vector(i_ci_node_index);
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                end            
            end      
        end
        %disp('決定此片段...')
        temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
        temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
        temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;    
    end
    %--
    % 整理X方向的線(最後一條)
    for i_x=temp_n:temp_n
        % 取出第某個X值的網格節點資訊
        temp_x_node_vector=xi_Node_3D(:,i_x);
        temp_y_node_vector=yi_Node_3D(:,i_x);
        temp_z_node_vector=zi_Node_3D(:,i_x);
        temp_ci_node_vector=ci_Node_3D_flat_nan(:,i_x-1);
        %--
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;
        %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
        %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
        for i_ci_node_index=1:length(temp_ci_node_vector)-1
            %disp(['#',num2str(i_ci_node_index),'=',num2str(temp_ci_node_vector(i_ci_node_index))])
            if isnan(temp_ci_node_vector(i_ci_node_index))==1
                if temp_start_x==0 && temp_end_x==0
                    %disp('略過')
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index);
                    temp_end_y=temp_y_node_vector(i_ci_node_index);
                    temp_end_z=temp_z_node_vector(i_ci_node_index);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                    %--
                    %disp('決定此片段...')
                    temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
                    temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
                    temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
                    temp_start_x=0;
                    temp_start_y=0;
                    temp_start_z=0;
                    temp_end_x=0;
                    temp_end_y=0;
                    temp_end_z=0;
                end
            else
                if temp_start_x==0 && temp_end_x==0
                    temp_start_x=temp_x_node_vector(i_ci_node_index);
                    temp_start_y=temp_y_node_vector(i_ci_node_index);
                    temp_start_z=temp_z_node_vector(i_ci_node_index);
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                end            
            end      
        end
        %disp('決定此片段...')
        temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
        temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
        temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;    
    end
    %--------------------------------------------------------------------------
    % 整理Y方向的線(第一條)
    for i_y=1:1
        % 取出第某個X值的網格節點資訊
        temp_x_node_vector=xi_Node_3D(i_y,:);
        temp_y_node_vector=yi_Node_3D(i_y,:);
        temp_z_node_vector=zi_Node_3D(i_y,:);
        temp_ci_node_vector=ci_Node_3D_flat_nan(i_y,:);
        %--
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;
        %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
        %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
        for i_ci_node_index=1:length(temp_ci_node_vector)-1
            %disp(['#',num2str(i_ci_node_index),'=',num2str(temp_ci_node_vector(i_ci_node_index))])
            if isnan(temp_ci_node_vector(i_ci_node_index))==1
                if temp_start_x==0 && temp_end_x==0
                    %disp('略過')
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index);
                    temp_end_y=temp_y_node_vector(i_ci_node_index);
                    temp_end_z=temp_z_node_vector(i_ci_node_index);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                    %--
                    %disp('決定此片段...')
                    temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
                    temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
                    temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
                    temp_start_x=0;
                    temp_start_y=0;
                    temp_start_z=0;
                    temp_end_x=0;
                    temp_end_y=0;
                    temp_end_z=0;
                end
            else
                if temp_start_x==0 && temp_end_x==0
                    temp_start_x=temp_x_node_vector(i_ci_node_index);
                    temp_start_y=temp_y_node_vector(i_ci_node_index);
                    temp_start_z=temp_z_node_vector(i_ci_node_index);
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                end            
            end      
        end
        %disp('決定此片段...')
        temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
        temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
        temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;    
    end
    %--
    % 整理Y方向的線(中間)
    for i_y=2:temp_m-1
        % 取出第某個Y值的網格節點資訊
        temp_x_node_vector=xi_Node_3D(i_y,:);
        temp_y_node_vector=yi_Node_3D(i_y,:);
        temp_z_node_vector=zi_Node_3D(i_y,:);
        temp_ci_node_vector=ci_Node_3D_flat_nan(i_y,:);
        temp_x_node_vector2=xi_Node_3D(i_y-1,:);
        temp_y_node_vector2=yi_Node_3D(i_y-1,:);
        temp_z_node_vector2=zi_Node_3D(i_y-1,:);
        temp_ci_node_vector2=ci_Node_3D_flat_nan(i_y-1,:);
        %--
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;
        %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
        %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
        for i_ci_node_index=1:length(temp_ci_node_vector)-1
            %disp(['#',num2str(i_ci_node_index),'=',num2str(temp_ci_node_vector(i_ci_node_index))])
            if isnan(temp_ci_node_vector(i_ci_node_index))==1 && isnan(temp_ci_node_vector2(i_ci_node_index))==1
                if temp_start_x==0 && temp_end_x==0
                    %disp('略過')
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index);
                    temp_end_y=temp_y_node_vector(i_ci_node_index);
                    temp_end_z=temp_z_node_vector(i_ci_node_index);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                    %--
                    %disp('決定此片段...')
                    temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
                    temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
                    temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
                    temp_start_x=0;
                    temp_start_y=0;
                    temp_start_z=0;
                    temp_end_x=0;
                    temp_end_y=0;
                    temp_end_z=0;
                end
            else
                if temp_start_x==0 && temp_end_x==0
                    temp_start_x=temp_x_node_vector(i_ci_node_index);
                    temp_start_y=temp_y_node_vector(i_ci_node_index);
                    temp_start_z=temp_z_node_vector(i_ci_node_index);
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                end            
            end      
        end
        %disp('決定此片段...')
        temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
        temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
        temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;    
    end
    %--
    % 整理Y方向的線(最後一條)
    for i_y=temp_m:temp_m
        % 取出第某個Y值的網格節點資訊
        temp_x_node_vector=xi_Node_3D(i_y,:);
        temp_y_node_vector=yi_Node_3D(i_y,:);
        temp_z_node_vector=zi_Node_3D(i_y,:);
        temp_ci_node_vector=ci_Node_3D_flat_nan(i_y-1,:);
        %--
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;
        %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
        %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
        for i_ci_node_index=1:length(temp_ci_node_vector)-1
            %disp(['#',num2str(i_ci_node_index),'=',num2str(temp_ci_node_vector(i_ci_node_index))])
            if isnan(temp_ci_node_vector(i_ci_node_index))==1
                if temp_start_x==0 && temp_end_x==0
                    %disp('略過')
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index);
                    temp_end_y=temp_y_node_vector(i_ci_node_index);
                    temp_end_z=temp_z_node_vector(i_ci_node_index);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                    %--
                    %disp('決定此片段...')
                    temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
                    temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
                    temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
                    temp_start_x=0;
                    temp_start_y=0;
                    temp_start_z=0;
                    temp_end_x=0;
                    temp_end_y=0;
                    temp_end_z=0;
                end
            else
                if temp_start_x==0 && temp_end_x==0
                    temp_start_x=temp_x_node_vector(i_ci_node_index);
                    temp_start_y=temp_y_node_vector(i_ci_node_index);
                    temp_start_z=temp_z_node_vector(i_ci_node_index);
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                else
                    temp_end_x=temp_x_node_vector(i_ci_node_index+1);
                    temp_end_y=temp_y_node_vector(i_ci_node_index+1);
                    temp_end_z=temp_z_node_vector(i_ci_node_index+1);
                    %disp(['片段起點:(',num2str(temp_start_x),',',num2str(temp_start_y),',',num2str(temp_start_z),')'])
                    %disp(['更新片段終點:(',num2str(temp_end_x),',',num2str(temp_end_y),',',num2str(temp_end_z),')'])
                end            
            end      
        end
        %disp('決定此片段...')
        temp_mesh_x_vector=[temp_mesh_x_vector,temp_start_x,temp_end_x,NaN];
        temp_mesh_y_vector=[temp_mesh_y_vector,temp_start_y,temp_end_y,NaN];
        temp_mesh_z_vector=[temp_mesh_z_vector,temp_start_z,temp_end_z,NaN];
        temp_start_x=0;
        temp_start_y=0;
        temp_start_z=0;
        temp_end_x=0;
        temp_end_y=0;
        temp_end_z=0;    
    end
    %--------------------------------------------------------------------------
    % 整理完的自訂網格資料
    custom_mesh_data_array=[temp_mesh_x_vector',temp_mesh_y_vector',temp_mesh_z_vector'];
    %--
    % 繪製自訂網格
    %plot3(custom_mesh_data_array(:,1),custom_mesh_data_array(:,2),custom_mesh_data_array(:,3),'r')
    %--------------------------------------------------------------------------
```
```matlab
% 本範例請搭配 make_custom_mesh_data.m 執行
clear;clc;close all
%--------------------------------------------------------------------------
% 相關繪圖指令提示:
% image系列:
% 只能在Z=0平面上畫的2D圖片，要處理3D不建議使用。
% surface系列:
% surface 主要的輸入方法是 surface(XI,YI,ZI,C)，是低階原生方法。不建議使用。
% surf 輸入方式幾乎與surface相同，但包裝了一些顏色控制、父層指定等。建議用這個。
% pcolor 主要輸入方法是 pcolor(XI,YI,C) 基本上就是強制ZI在0的surf，也有包裝顏色控制、父層指定。也不建議使用。
%--------------------------------------------------------------------------
% 4D強度圖展示介紹
%--
% 準備4D強度資料(Scalar Volume Data，我稱之為「4D Scalar Volume Data」)。
% MATLAB建議可用slice、isosurface方法來展示。
% REF:https://www.mathworks.com/help/matlab/visualize/overview-of-volume-visualization.html
%--
% 其中，4D Scalar Volume Data由大寫的XI,YI,ZI,CI所組成，皆為3維陣列。
% 大寫XI、YI、ZI、CI依照本人寫作習慣留給4D使用。
% --
% 依照本人定義，此資料的描述方式是以網格節點為主，因此改為:
% 網格資料為:XI_Node_4D、YI_Node_4D、ZI_Node_4D。為3維陣列。
% 對應的強度值在網格節點上的值就必須為CI_Node_4D_interp。為3維陣列。
%--
% 立體模型中，體素(Voxel)，或稱體積像素(Volume Pixel)類型的資料則不是落在網格節
% 點上，而是體素之間的界面形成網格線，此時就可以用下列方式儲存:
% 對應的強度值在塊體中心的值就必須為CI_Node_4D_flat_nan(把用不到的部分填nan)或
% CI_Node_4D_flat_inf(把用不到的部分填nan)。為3維陣列。
% 
% 範例:
[XI_Node_4D,YI_Node_4D,ZI_Node_4D] = meshgrid(1:5,1:4,1:3);
CI_Node_4D_interp=zeros(size(XI_Node_4D));
for i=1:numel(CI_Node_4D_interp)
    CI_Node_4D_interp(i)=i;
end
%--
% X方向有5個節點，Y方向上有4個節點，Z方向上有3個節點，則大小為<4x5x3>。
% 注意，很麻煩的是XY是寫成矩陣，Y大小在前，X大小在後，第三個是Z大小。
% XI_Node_4D可展示為
% XI_Node_4D(:,:,1) =
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
% XI_Node_4D(:,:,2) =
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
% XI_Node_4D(:,:,3) =
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
%      1     2     3     4     5
% YI_Node_4D可展示為
% YI_Node_4D(:,:,1) =
%      1     1     1     1     1
%      2     2     2     2     2
%      3     3     3     3     3
%      4     4     4     4     4
% YI_Node_4D(:,:,2) =
%      1     1     1     1     1
%      2     2     2     2     2
%      3     3     3     3     3
%      4     4     4     4     4
% YI_Node_4D(:,:,3) =
%      1     1     1     1     1
%      2     2     2     2     2
%      3     3     3     3     3
%      4     4     4     4     4
% ZI_Node_4D可展示為
% ZI_Node_4D(:,:,1) =
%      1     1     1     1     1
%      1     1     1     1     1
%      1     1     1     1     1
%      1     1     1     1     1
% ZI_Node_4D(:,:,2) =
%      2     2     2     2     2
%      2     2     2     2     2
%      2     2     2     2     2
%      2     2     2     2     2
% ZI_Node_4D(:,:,3) =
%      3     3     3     3     3
%      3     3     3     3     3
%      3     3     3     3     3
%      3     3     3     3     3
% 強度值(顏色)CI_Node_4D_interp陣列可以展示為:
% CI_Node_4D_interp(:,:,1) =
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
% CI_Node_4D_interp(:,:,2) =
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
% CI_Node_4D_interp(:,:,3) =
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%      0     0     0     0     0
%--------------------------------------------------------------------------

%--------------------------------------------------------------------------
% 製作CI_Node_4D_flat_nan:
%--
CI_Node_4D_flat_nan=CI_Node_4D_interp;CI_Node_4D_flat_nan(:,:,end)=NaN;CI_Node_4D_flat_nan(:,end,:)=NaN;CI_Node_4D_flat_nan(end,:,:)=NaN;
% 強度值(顏色)CI_Node_4D_flat_nan陣列可以展示為:
% CI_Node_4D_flat_nan(:,:,1) =
%      1     5     9    13   NaN
%      2     6    10    14   NaN
%      3     7    11    15   NaN
%    NaN   NaN   NaN   NaN   NaN
% CI_Node_4D_flat_nan(:,:,2) =
%     21    25    29    33   NaN
%     22    26    30    34   NaN
%     23    27    31    35   NaN
%    NaN   NaN   NaN   NaN   NaN
% CI_Node_4D_flat_nan(:,:,3) =
%    NaN   NaN   NaN   NaN   NaN
%    NaN   NaN   NaN   NaN   NaN
%    NaN   NaN   NaN   NaN   NaN
%    NaN   NaN   NaN   NaN   NaN
% --
% 注意!CI_Node_4D_flat_nan用在slice方法的時候，邊界會切不出來。
% 注意!CI_Node_4D_flat_inf用在slice方法的時候，邊界會切出異常值。
%--------------------------------------------------------------------------

%--------------------------------------------------------------------------
% 繪製Voxel立體圖
%--
% 找出各方向網格節點數量
[Y_Node_count,X_Node_count,Z_Node_count]=size(CI_Node_4D_flat_nan);
%--
% 找出元素數量，這裡其實是各方向上的體素數量
X_Element_count=X_Node_count-1;
Y_Element_count=Y_Node_count-1;
Z_Element_count=Z_Node_count-1;
%--------------------------------------------------------------------------
% 挖空不要的體素
CI_Node_4D_flat_nan([7:12,25:end])=NaN;
%--
figure
hold on
xlabel('X')
ylabel('Y')
zlabel('Z')
view(-45,45)
xlim([min(XI_Node_4D(:)),max(XI_Node_4D(:))])
ylim([min(YI_Node_4D(:)),max(YI_Node_4D(:))])
zlim([min(ZI_Node_4D(:)),max(ZI_Node_4D(:))])
set(gca,'CLim',[1,30])
colorbar
%--
% 準備XY面的Voxel表面資料，分為前面與後面
for i=1:Z_Element_count
    %--
    Voxel_XYplane{i}.Front.xi_Node_3D=XI_Node_4D(:,:,i);
    Voxel_XYplane{i}.Front.yi_Node_3D=YI_Node_4D(:,:,i);
    Voxel_XYplane{i}.Front.zi_Node_3D=ZI_Node_4D(:,:,i);
    Voxel_XYplane{i}.Front.ci_Node_3D_flat_nan=CI_Node_4D_flat_nan(:,:,i);
    surf(...
        Voxel_XYplane{i}.Front.xi_Node_3D,...
        Voxel_XYplane{i}.Front.yi_Node_3D,...
        Voxel_XYplane{i}.Front.zi_Node_3D,...
        Voxel_XYplane{i}.Front.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    Voxel_XYplane{i}.Front.mesh_data_array=make_custom_mesh_data(...
        Voxel_XYplane{i}.Front.xi_Node_3D,...
        Voxel_XYplane{i}.Front.yi_Node_3D,...
        Voxel_XYplane{i}.Front.zi_Node_3D,...
        Voxel_XYplane{i}.Front.ci_Node_3D_flat_nan...
        );
    plot3(...
        Voxel_XYplane{i}.Front.mesh_data_array(:,1),...
        Voxel_XYplane{i}.Front.mesh_data_array(:,2),...
        Voxel_XYplane{i}.Front.mesh_data_array(:,3),...
        'Color',[0,0,0])
    %--
    Voxel_XYplane{i}.Back.xi_Node_3D=XI_Node_4D(:,:,i);
    Voxel_XYplane{i}.Back.yi_Node_3D=YI_Node_4D(:,:,i);
    Voxel_XYplane{i}.Back.zi_Node_3D=ZI_Node_4D(:,:,i+1);
    Voxel_XYplane{i}.Back.ci_Node_3D_flat_nan=CI_Node_4D_flat_nan(:,:,i);
    surf(...
        Voxel_XYplane{i}.Back.xi_Node_3D,...
        Voxel_XYplane{i}.Back.yi_Node_3D,...
        Voxel_XYplane{i}.Back.zi_Node_3D,...
        Voxel_XYplane{i}.Back.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    Voxel_XYplane{i}.Back.mesh_data_array=make_custom_mesh_data(...
        Voxel_XYplane{i}.Back.xi_Node_3D,...
        Voxel_XYplane{i}.Back.yi_Node_3D,...
        Voxel_XYplane{i}.Back.zi_Node_3D,...
        Voxel_XYplane{i}.Back.ci_Node_3D_flat_nan...
        );
    plot3(...
        Voxel_XYplane{i}.Back.mesh_data_array(:,1),...
        Voxel_XYplane{i}.Back.mesh_data_array(:,2),...
        Voxel_XYplane{i}.Back.mesh_data_array(:,3),...
        'Color',[0,0,0])
    %--
end
%--
% 準備YZ面的Voxel表面資料，分為前面與後面
for i=1:X_Element_count
    %--
    Voxel_YZplane{i}.Front.xi_Node_3D=permute(XI_Node_4D(:,i,:),[1,3,2]);
    Voxel_YZplane{i}.Front.yi_Node_3D=permute(YI_Node_4D(:,i,:),[1,3,2]);
    Voxel_YZplane{i}.Front.zi_Node_3D=permute(ZI_Node_4D(:,i,:),[1,3,2]);
    Voxel_YZplane{i}.Front.ci_Node_3D_flat_nan=permute(CI_Node_4D_flat_nan(:,i,:),[1,3,2]);
    surf(...
        Voxel_YZplane{i}.Front.xi_Node_3D,...
        Voxel_YZplane{i}.Front.yi_Node_3D,...
        Voxel_YZplane{i}.Front.zi_Node_3D,...
        Voxel_YZplane{i}.Front.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    Voxel_YZplane{i}.Front.mesh_data_array=make_custom_mesh_data(...
        Voxel_YZplane{i}.Front.xi_Node_3D,...
        Voxel_YZplane{i}.Front.yi_Node_3D,...
        Voxel_YZplane{i}.Front.zi_Node_3D,...
        Voxel_YZplane{i}.Front.ci_Node_3D_flat_nan...
        );
    plot3(...
        Voxel_YZplane{i}.Front.mesh_data_array(:,1),...
        Voxel_YZplane{i}.Front.mesh_data_array(:,2),...
        Voxel_YZplane{i}.Front.mesh_data_array(:,3),...
        'Color',[0,0,0])
    %--
    Voxel_YZplane{i}.Back.xi_Node_3D=permute(XI_Node_4D(:,i+1,:),[1,3,2]);
    Voxel_YZplane{i}.Back.yi_Node_3D=permute(YI_Node_4D(:,i,:),[1,3,2]);
    Voxel_YZplane{i}.Back.zi_Node_3D=permute(ZI_Node_4D(:,i,:),[1,3,2]);
    Voxel_YZplane{i}.Back.ci_Node_3D_flat_nan=permute(CI_Node_4D_flat_nan(:,i,:),[1,3,2]);
    surf(...
        Voxel_YZplane{i}.Back.xi_Node_3D,...
        Voxel_YZplane{i}.Back.yi_Node_3D,...
        Voxel_YZplane{i}.Back.zi_Node_3D,...
        Voxel_YZplane{i}.Back.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    Voxel_YZplane{i}.Back.mesh_data_array=make_custom_mesh_data(...
        Voxel_YZplane{i}.Back.xi_Node_3D,...
        Voxel_YZplane{i}.Back.yi_Node_3D,...
        Voxel_YZplane{i}.Back.zi_Node_3D,...
        Voxel_YZplane{i}.Back.ci_Node_3D_flat_nan...
        );
    plot3(...
        Voxel_YZplane{i}.Back.mesh_data_array(:,1),...
        Voxel_YZplane{i}.Back.mesh_data_array(:,2),...
        Voxel_YZplane{i}.Back.mesh_data_array(:,3),...
        'Color',[0,0,0])
    %--
end
%--
% 準備XZ面的Voxel表面資料，分為前面與後面
for i=1:Y_Element_count
    %--
    Voxel_XZplane{i}.Front.xi_Node_3D=permute(XI_Node_4D(i,:,:),[3,2,1]);
    Voxel_XZplane{i}.Front.yi_Node_3D=permute(YI_Node_4D(i,:,:),[3,2,1]);
    Voxel_XZplane{i}.Front.zi_Node_3D=permute(ZI_Node_4D(i,:,:),[3,2,1]);
    Voxel_XZplane{i}.Front.ci_Node_3D_flat_nan=permute(CI_Node_4D_flat_nan(i,:,:),[3,2,1]);
    surf(...
        Voxel_XZplane{i}.Front.xi_Node_3D,...
        Voxel_XZplane{i}.Front.yi_Node_3D,...
        Voxel_XZplane{i}.Front.zi_Node_3D,...
        Voxel_XZplane{i}.Front.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    Voxel_XZplane{i}.Front.mesh_data_array=make_custom_mesh_data(...
        Voxel_XZplane{i}.Front.xi_Node_3D,...
        Voxel_XZplane{i}.Front.yi_Node_3D,...
        Voxel_XZplane{i}.Front.zi_Node_3D,...
        Voxel_XZplane{i}.Front.ci_Node_3D_flat_nan...
        );
    plot3(...
        Voxel_XZplane{i}.Front.mesh_data_array(:,1),...
        Voxel_XZplane{i}.Front.mesh_data_array(:,2),...
        Voxel_XZplane{i}.Front.mesh_data_array(:,3),...
        'Color',[0,0,0])
    %--
    Voxel_XZplane{i}.Back.xi_Node_3D=permute(XI_Node_4D(i,:,:),[3,2,1]);
    Voxel_XZplane{i}.Back.yi_Node_3D=permute(YI_Node_4D(i+1,:,:),[3,2,1]);
    Voxel_XZplane{i}.Back.zi_Node_3D=permute(ZI_Node_4D(i,:,:),[3,2,1]);
    Voxel_XZplane{i}.Back.ci_Node_3D_flat_nan=permute(CI_Node_4D_flat_nan(i,:,:),[3,2,1]);
    surf(...
        Voxel_XZplane{i}.Back.xi_Node_3D,...
        Voxel_XZplane{i}.Back.yi_Node_3D,...
        Voxel_XZplane{i}.Back.zi_Node_3D,...
        Voxel_XZplane{i}.Back.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    Voxel_XZplane{i}.Back.mesh_data_array=make_custom_mesh_data(...
        Voxel_XZplane{i}.Back.xi_Node_3D,...
        Voxel_XZplane{i}.Back.yi_Node_3D,...
        Voxel_XZplane{i}.Back.zi_Node_3D,...
        Voxel_XZplane{i}.Back.ci_Node_3D_flat_nan...
        );
    plot3(...
        Voxel_XZplane{i}.Back.mesh_data_array(:,1),...
        Voxel_XZplane{i}.Back.mesh_data_array(:,2),...
        Voxel_XZplane{i}.Back.mesh_data_array(:,3),...
        'Color',[0,0,0])
    %--
end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% 配合shading faceted做比較
figure
hold on
xlabel('X')
ylabel('Y')
zlabel('Z')
view(-45,45)
xlim([min(XI_Node_4D(:)),max(XI_Node_4D(:))])
ylim([min(YI_Node_4D(:)),max(YI_Node_4D(:))])
zlim([min(ZI_Node_4D(:)),max(ZI_Node_4D(:))])
set(gca,'CLim',[1,30])
colorbar
%--
% 準備XY面的Voxel表面資料，分為前面與後面
for i=1:Z_Element_count
    %--
    surf(...
        Voxel_XYplane{i}.Front.xi_Node_3D,...
        Voxel_XYplane{i}.Front.yi_Node_3D,...
        Voxel_XYplane{i}.Front.zi_Node_3D,...
        Voxel_XYplane{i}.Front.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    surf(...
        Voxel_XYplane{i}.Back.xi_Node_3D,...
        Voxel_XYplane{i}.Back.yi_Node_3D,...
        Voxel_XYplane{i}.Back.zi_Node_3D,...
        Voxel_XYplane{i}.Back.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    %--
end
%--
% 準備YZ面的Voxel表面資料，分為前面與後面
for i=1:X_Element_count
    %--
    surf(...
        Voxel_YZplane{i}.Front.xi_Node_3D,...
        Voxel_YZplane{i}.Front.yi_Node_3D,...
        Voxel_YZplane{i}.Front.zi_Node_3D,...
        Voxel_YZplane{i}.Front.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    surf(...
        Voxel_YZplane{i}.Back.xi_Node_3D,...
        Voxel_YZplane{i}.Back.yi_Node_3D,...
        Voxel_YZplane{i}.Back.zi_Node_3D,...
        Voxel_YZplane{i}.Back.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    %--
end
%--
% 準備XZ面的Voxel表面資料，分為前面與後面
for i=1:Y_Element_count
    surf(...
        Voxel_XZplane{i}.Front.xi_Node_3D,...
        Voxel_XZplane{i}.Front.yi_Node_3D,...
        Voxel_XZplane{i}.Front.zi_Node_3D,...
        Voxel_XZplane{i}.Front.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    surf(...
        Voxel_XZplane{i}.Back.xi_Node_3D,...
        Voxel_XZplane{i}.Back.yi_Node_3D,...
        Voxel_XZplane{i}.Back.zi_Node_3D,...
        Voxel_XZplane{i}.Back.ci_Node_3D_flat_nan,...
        'FaceColor','flat','EdgeColor','none'...
        );
    %--
end
shading faceted
%--------------------------------------------------------------------------
% 注意!舊版MATLAB可能在尺寸太小的繪圖上有錯誤，會透視到後面的東西，用新版應該不會有這個問題。
% 測試R2009A太小會有透視情形，R2014a沒有問題。
%--------------------------------------------------------------------------
```
